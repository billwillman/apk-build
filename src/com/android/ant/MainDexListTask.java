/*
 * Copyright (C) 2015 LimeFamily.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.ant;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.types.FileSet;
import org.apache.tools.ant.types.Path;
import org.apache.tools.ant.types.resources.FileResource;

public class MainDexListTask extends SingleDependencyTask {

    private String mOutput;
    private String mFilterList;
    private String mMappingFile;
    private List<Path> mPathInputs;
    private List<FileSet> mFileSetInputs;

    class Filter {
        private String start;
        private String end;
        
        public Filter(String start, String end) {
            this.start = start;
            this.end = end;
        }

        public String getStart() {
            return start;
        }

        public String getEnd() {
            return end;
        }
    }

    /**
     * Sets the value of the "output" attribute.
     * @param output the value.
     */
    public void setOutput(Path output) {
        mOutput = TaskHelper.checkSinglePath("output", output);
    }

    /**
     * Sets the filter list file of the main dex list.
     * @param filterList the path.
     */
    public void setFilterList(String filterList) {
        this.mFilterList = filterList;
    }

    /**
     * Sets the mapping file generated by proguard.
     * @param mappingFile the path.
     */
    public void setMappingFile(String mappingFile) {
        this.mMappingFile = mappingFile;
    }

    /**
     * Returns an object representing a nested <var>path</var> element.
     */
    public Object createPath() {
        if (mPathInputs == null) {
            mPathInputs = new ArrayList<Path>();
        }

        Path path = new Path(getProject());
        mPathInputs.add(path);

        return path;
    }

    /**
     * Returns an object representing a nested <var>path</var> element.
     */
    public Object createFileSet() {
        if (mFileSetInputs == null) {
            mFileSetInputs = new ArrayList<FileSet>();
        }

        FileSet fs = new FileSet();
        fs.setProject(getProject());
        mFileSetInputs.add(fs);

        return fs;
    }


    @Override
    public void execute() throws BuildException {

        // get all input paths
        List<File> paths = new ArrayList<File>();
        if (mPathInputs != null) {
            for (Path pathList : mPathInputs) {
                for (String path : pathList.list()) {
                    System.out.println("input: " + path);
                    paths.add(new File(path));
                }
            }
        }

        if (mFileSetInputs != null) {
            for (FileSet fs : mFileSetInputs) {
                Iterator<?> iter = fs.iterator();
                while (iter.hasNext()) {
                    FileResource fr = (FileResource) iter.next();
                    System.out.println("input: " + fr.getFile().toString());
                    paths.add(fr.getFile());
                }
            }
        }

        // figure out the path to the dependency file.
        String depFile = mOutput + ".d";

        // get InputPath with no extension restrictions
        List<InputPath> inputPaths = getInputPaths(paths, null /*extensionsToCheck*/,
                null /*factory*/);

        if (initDependencies(depFile, inputPaths) && dependenciesHaveChanged() == false) {
            System.out.println(
                    "No new compiled code. No need to generate new list file.");
            return;
        }

        System.out.println(String.format(
                "Generating main dex list file into %1$s...", mOutput));

        listGen(paths, mOutput, mFilterList, mMappingFile);

        // generate the dependency file.
        generateDependencyFile(depFile, inputPaths, mOutput);
    }
    
    private List<Filter> initFilters(String filterList) {
        List<Filter> filters = null;
        BufferedReader reader = null;
        
        try {
            File file = new File(filterList);
            FileInputStream inputStream = new FileInputStream(file);
            InputStreamReader streamReader = new InputStreamReader(inputStream);
            
            reader = new BufferedReader(streamReader);
            filters = new ArrayList<Filter>();
            
            String line = null;
            
            while ((line = reader.readLine()) != null) {
                int cast = line.indexOf('*');
                if (cast != -1) {
                    String start = null, end = null;
                    if (cast > 1) {
                        start = line.substring(0, cast);
                    }
                    if (cast < line.length() - 1) {
                        end = line.substring(cast + 1);
                    }
                    if (start != null) {
                        filters.add(new Filter(start, end));
                    }
                } else if (line.endsWith(".class")) {
                    filters.add(new Filter(line, null));
                }
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        return filters;
    }

    private List<String> loadFromMapping(String mappingFile, List<Filter> filters) {
        List<String> classes = null;
        BufferedReader reader = null;
        
        try {
            File file = new File(mappingFile);
            FileInputStream inputStream = new FileInputStream(file);
            InputStreamReader streamReader = new InputStreamReader(inputStream);
            
            reader = new BufferedReader(streamReader);
            classes = new ArrayList<String>();
            
            Pattern pattern = Pattern.compile("([^ ]+) -> ([^ ]+):");
            String line = null;
            
            while ((line = reader.readLine()) != null) {
                Matcher matcher = pattern.matcher(line);
                if (matcher.matches()) {
                    String origin = matcher.group(1).replace('.', '/') + ".class";
                    if (filterMatch(origin, filters)) {
                        classes.add(matcher.group(2).replace('.', '/') + ".class");
                    }
                }
            }
            
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        return classes;
    }
    
    private void loadClasses(File folder, String prefix, List<String> classes) {
        if (prefix == null) {
            prefix = "";
        }
        
        String[] list = folder.list();
        String folderPath = folder.getAbsolutePath() + File.separator;
        
        for (String name : list) {
            File file = new File(folderPath + name);
            if (file.isDirectory()) {
                loadClasses(file, prefix + name + "/", classes);
            } else if (name.endsWith(".class")) {
                classes.add(prefix + name);
            }
        }
    }

    private boolean filterMatch(String input, List<Filter> filters) {
        for (Filter filter : filters) {
            if (input.startsWith(filter.getStart())) {
                if (filter.getEnd() == null || input.endsWith(filter.getEnd())) {
                    return true;
                }
            }
        }
        return false;
    }

    private void listGen(Collection<File> inputs, String output, String filterList, String mappingFile) {
        List<Filter> filters = initFilters(filterList);
        if (filters == null || filters.size() == 0) {
            throw new BuildException("Error when loading main dex list filters.");
        }
        
        File outFile = new File(output);
        BufferedWriter writer = null;
        try {
            FileOutputStream outputStream = new FileOutputStream(outFile);
            OutputStreamWriter streamWriter = new OutputStreamWriter(outputStream);
            writer = new BufferedWriter(streamWriter);
        } catch (Exception e) {
            throw new BuildException("Error create output file.");
        }

        List<String> clazzes = loadFromMapping(mappingFile, filters);
        if (clazzes != null) {
            for (String clazz : clazzes) {
                try {
                    writer.write(clazz);
                    writer.newLine();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        for (File file : inputs) {
            if (file.isDirectory()) {
                List<String> classes = new ArrayList<String>();
                loadClasses(file, null, classes);
                
                for (String path : classes) {
                    if (filterMatch(path, filters)) {
                        try {
                            writer.write(path);
                            writer.newLine();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                }
                
                continue;
            }
            
            ZipFile zipFile = null;
            
            try {
                zipFile = new ZipFile(file);
                Enumeration<? extends ZipEntry> zipEntries = zipFile.entries();
                
                while (zipEntries.hasMoreElements()) {
                    
                    ZipEntry zipEntry = zipEntries.nextElement();
                    if (!zipEntry.isDirectory()) {
                        
                        String entryName = zipEntry.getName();
                        if (entryName.endsWith(".class")) {
                            
                            if (filterMatch(entryName, filters)) {
                                
                                if (clazzes != null && clazzes.contains(entryName)) {
                                    continue;
                                }
                                
                                try {
                                    writer.write(entryName);
                                    writer.newLine();
                                } catch (IOException e) {
                                    e.printStackTrace();
                                }
                            }
                        }
                    }
                }
                
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (zipFile != null) {
                    try {
                        zipFile.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
        
        try {
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    protected String getExecTaskName() {
        return "maindexlist";
    }

}
